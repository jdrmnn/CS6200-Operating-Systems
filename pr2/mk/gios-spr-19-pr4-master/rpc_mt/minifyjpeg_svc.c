/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */
#include "magickminify.h"
#include "minifyjpeg.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/signal.h>
#include <errno.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <netinet/in.h>
#include <pthread.h>
#include "steque.h"
#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif


typedef struct{
  struct svc_req *rqstp;
  SVCXPRT *transp;
	xdrproc_t _xdr_argument; //input image
  xdrproc_t _xdr_result; // output image
  img_in argument;
	img_out result;
}steque_node;

/* global variable initialization*/
pthread_cond_t mutex_cv=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex;
steque_t *req_queue;
/* declare the thread function*/
void *threadFunc(void *threadid);

#define USAGE                                                                 \
"usage:\n"                                                                    \
"  webclient [options]\n"                                                     \
"options:\n"                                                                  \
"  -h                  Show this help message\n"                              \
"  -t [nthreads]       Number of threads (Default 9)\n"                       \

/* OPTIONS DESCRIPTOR ====================================================== */
static struct option gLongOptions[] = {
  {"help",          no_argument,            NULL,           'h'},
  {"nthreads",      required_argument,      NULL,           't'},
  {NULL,            0,                      NULL,             0}
};

//
// static void Usage() {
// 	fprintf(stderr, "%s", USAGE);
// }
//


int
_minifyjpeg_proc_1 (img_in  *argp, void *result, struct svc_req *rqstp)
{
	return (minifyjpeg_proc_1_svc(*argp, result, rqstp));
}

static void
minifyjpeg_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{

	img_in argument;

	xdrproc_t _xdr_argument, _xdr_result;

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case MINIFYJPEG_PROC:
		_xdr_argument = (xdrproc_t) xdr_img_in;
		_xdr_result = (xdrproc_t) xdr_img_out;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}

	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}



		steque_node* node;
    node = (steque_node*)malloc(sizeof(steque_node));
    node->rqstp = rqstp;
    node->transp = transp;
    node->_xdr_argument = _xdr_argument;
		node->_xdr_result = _xdr_result;
    node->argument = argument;
    // node->result = result;
		if(pthread_mutex_lock(&mutex)!=0){
			printf("\n mutex lock has failed\n");
			exit(1);
		}
		steque_enqueue(req_queue,node);

		if(pthread_mutex_unlock(&mutex)!=0){
			printf("\n mutex unlock has failed\n");
			exit(1);
		}
		/* Signal the worker thread*/
		pthread_cond_signal(&mutex_cv);


	return;
}

int
main (int argc, char **argv)
{
	register SVCXPRT *transp;
	int nthreads = 1; //1
  int option_char = 0;
	// Parse and set command line arguments
  while ((option_char = getopt_long(argc, argv, "t:hr", gLongOptions, NULL)) != -1) {
    switch (option_char) {
      case 't': // nthreads
        nthreads = atoi(optarg);
        break;
      case 'h': // help
        fprintf(stdout, "%s", USAGE);
        exit(0);
        break;
      default:
        fprintf(stderr, "%s", USAGE);
        exit(1);
    }
  }

	/* not useful, but it ensures the initial code builds without warnings */
  if (nthreads < 1) {
    nthreads = 1;
  }

// initialize req_queue
	req_queue = (steque_t *)malloc(sizeof(steque_t));
	steque_init(req_queue);
	pthread_t tid[nthreads];
	int t, tNum[nthreads];
	// printf("========The client starts to set pthreads ========\n");
	if (pthread_mutex_init(&mutex, NULL) != 0){
			fprintf(stderr, "\n mutex init has failed\n");
			exit(1);
	}
	for(t=0; t<nthreads; t++){
		/* create the threads; may be any number, in general */
		tNum[t] = t;
		if(pthread_create(&tid[t], NULL, threadFunc, &tNum[t]) != 0) {
			fprintf(stderr, "Unable to create producer thread\n");
			exit(1);
		}
		// printf("------Thread %d is created!----\n",t );
	}

	pmap_unset (MINIFYJPEG_PROG, MINIFYJPEG_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, MINIFYJPEG_PROG, MINIFYJPEG_VERS, minifyjpeg_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (MINIFYJPEG_PROG, MINIFYJPEG_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, MINIFYJPEG_PROG, MINIFYJPEG_VERS, minifyjpeg_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (MINIFYJPEG_PROG, MINIFYJPEG_VERS, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");

  /* destroy the queue and free the memory space */
  steque_destroy(req_queue);
	exit (1);
	/* NOTREACHED */
}


/* worker thread handles the request*/
void *threadFunc(void *pArg){
  // int threadnum = *((int*)pArg);
  steque_node* req_obj;
  int returncode = 0;
  bool_t retval;
  bool_t (*local)(char *, void *, struct svc_req *);
  img_out result;
  while(1){
    if(pthread_mutex_lock(&mutex)!=0){
      printf("\n mutex lock has failed\n");
      exit(1);
    }
        while(steque_isempty(req_queue)){
          pthread_cond_wait(&mutex_cv, &mutex);
        }
    req_obj = steque_pop(req_queue);

    if(pthread_mutex_unlock(&mutex)!=0){
      printf("\n mutex unlock has failed\n");
      exit(1);
    }
    /* signal other threads*/
    pthread_cond_signal(&mutex_cv);

    if(req_obj!=NULL){
      local = (bool_t (*) (char *, void *,  struct svc_req *))_minifyjpeg_proc_1;
      retval = (bool_t) (*local)((char *)&req_obj->argument, (void *)&req_obj->result, req_obj->rqstp);
    	if (retval > 0 && !svc_sendreply(req_obj->transp, (xdrproc_t) req_obj->_xdr_result, (char *)&req_obj->result)) {
    		svcerr_systemerr (req_obj->transp);
    	}
    	if (!svc_freeargs (req_obj->transp, (xdrproc_t) req_obj->_xdr_argument, (caddr_t) &req_obj->argument)) {
    		fprintf (stderr, "%s", "unable to free arguments");
    		exit (1);
    	}
    	// if (!minifyjpeg_prog_1_freeresult (req_obj->transp, req_obj->_xdr_result, (caddr_t) &req_obj->result))
    	// 	fprintf (stderr, "%s", "unable to free results");

      free(req_obj);
      req_obj = NULL;
    }
  }
}
